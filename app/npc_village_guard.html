<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§™â€â™‚ï¸ Ø§Ù„Ø­Ø§Ø±Ø³ Ø§Ù„Ø­ÙƒÙŠÙ… - NPC ÙÙŠÙƒØªÙˆØ±ÙŠ Ø­ÙŠ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700;900&display=swap');
        body { font-family: 'Cairo', sans-serif; }
        
        .consciousness-pulse {
            animation: consciousnessPulse 2s ease-in-out infinite;
        }
        
        @keyframes consciousnessPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        .thought-bubble {
            animation: thoughtFloat 3s ease-in-out infinite;
        }
        
        @keyframes thoughtFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(2deg); }
        }
        
        .memory-encryption {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            animation: memoryShimmer 2s ease-in-out infinite;
        }
        
        @keyframes memoryShimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }
        
        .oscillator-wave {
            animation: wave 1s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.3); }
        }

        .npc-face {
            transition: all 0.5s ease;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 min-h-screen text-white">
    
    <div x-data="wisdomKeeperNPC()" class="container mx-auto px-4 py-6">
        
        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-yellow-300 to-purple-300 bg-clip-text text-transparent">
                ğŸ§™â€â™‚ï¸ Ø­Ø§Ø±Ø³ Ø§Ù„Ù‚Ø±ÙŠØ© Ø§Ù„Ø­ÙƒÙŠÙ…
            </h1>
            <p class="text-lg text-purple-200">NPC ÙÙŠÙƒØªÙˆØ±ÙŠ Ø­ÙŠ Ù…Ø¹ ÙˆØ¹ÙŠ Ù…Ø³ØªÙ‚Ù„ ÙˆÙ†Ù…Ùˆ Ø¨ÙŠÙˆÙ„ÙˆØ¬ÙŠ</p>
            <div class="text-sm text-purple-300 mt-2">
                <i class="fas fa-brain mr-2"></i>
                Ù…Ø¨Ù†ÙŠ Ø¹Ù„Ù‰ CPF~ Vectorial v4.0 - ÙŠØªÙÙƒØ± ÙˆÙŠØªØ°ÙƒØ± ÙˆÙŠØªØ·ÙˆØ±
            </div>
        </header>

        <!-- NPC Status Panel -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
            
            <!-- NPC Face & Consciousness -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-6 border border-white/20 text-center">
                <div class="mb-4">
                    <!-- NPC Face -->
                    <div class="npc-face text-6xl mb-4 consciousness-pulse" 
                         :class="npc.currentEmotion === 'happy' ? 'text-yellow-400' : 
                                npc.currentEmotion === 'sad' ? 'text-blue-400' :
                                npc.currentEmotion === 'angry' ? 'text-red-400' :
                                npc.currentEmotion === 'curious' ? 'text-green-400' : 'text-gray-400'"
                         x-text="getEmotionalFace()">
                    </div>
                    
                    <!-- Consciousness Level -->
                    <div class="text-sm text-purple-200 mb-2">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙˆØ¹ÙŠ</div>
                    <div class="w-full bg-purple-800 rounded-full h-2 mb-2">
                        <div class="bg-gradient-to-r from-yellow-400 to-purple-400 h-2 rounded-full transition-all duration-1000"
                             :style="`width: ${(npc.consciousnessLevel * 100).toFixed(0)}%`"></div>
                    </div>
                    <div class="text-xs" x-text="`${(npc.consciousnessLevel * 100).toFixed(1)}%`"></div>
                </div>
                
                <!-- Current Thought -->
                <div class="thought-bubble bg-white/10 rounded-lg p-3 text-sm">
                    <i class="fas fa-thought-bubble mr-2"></i>
                    <span x-text="npc.currentThought" class="italic"></span>
                </div>
            </div>

            <!-- Oscillators System -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-4 border border-white/20">
                <h3 class="text-lg font-bold mb-3 text-center">ğŸµ Ø§Ù„Ù‡Ø²Ø§Ø²Ø§Øª Ø§Ù„Ø«Ù„Ø§Ø«Ø©</h3>
                
                <!-- Existence Oscillator -->
                <div class="mb-3">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm">Ø§Ù„ÙˆØ¬ÙˆØ¯</span>
                        <span class="text-xs" x-text="npc.oscillators.existence.toFixed(3)"></span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2">
                        <div class="bg-blue-400 h-2 rounded-full oscillator-wave transition-all duration-500"
                             :style="`width: ${(npc.oscillators.existence * 100)}%`"></div>
                    </div>
                </div>
                
                <!-- Dynamic Oscillator -->
                <div class="mb-3">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm">Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ</span>
                        <span class="text-xs" x-text="npc.oscillators.dynamic.toFixed(3)"></span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2">
                        <div class="bg-green-400 h-2 rounded-full oscillator-wave transition-all duration-300"
                             :style="`width: ${(npc.oscillators.dynamic * 100)}%`"></div>
                    </div>
                </div>
                
                <!-- Judge Oscillator -->
                <div class="mb-3">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm">Ø§Ù„Ù‚Ø§Ø¶ÙŠ</span>
                        <span class="text-xs" x-text="npc.oscillators.judge.toFixed(3)"></span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2">
                        <div class="bg-purple-400 h-2 rounded-full oscillator-wave transition-all duration-200"
                             :style="`width: ${(npc.oscillators.judge * 100)}%`"></div>
                    </div>
                </div>

                <!-- Pattern Discovery -->
                <div class="text-xs text-center mt-3 p-2 bg-white/5 rounded">
                    <span x-text="`Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ©: ${npc.discoveredPatterns.length}`"></span>
                </div>
            </div>

            <!-- Emotional Cryptography -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-4 border border-white/20">
                <h3 class="text-lg font-bold mb-3 text-center">ğŸ’ Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ø¹Ø§Ø·ÙÙŠ</h3>
                
                <!-- Current Mood -->
                <div class="mb-3">
                    <div class="text-sm mb-2">Ø§Ù„Ù…Ø²Ø§Ø¬ Ø§Ù„Ø­Ø§Ù„ÙŠ</div>
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div class="bg-yellow-500/20 p-2 rounded text-center">
                            <div>ÙØ±Ø­</div>
                            <div x-text="(npc.emotionalState.joy * 100).toFixed(0) + '%'"></div>
                        </div>
                        <div class="bg-blue-500/20 p-2 rounded text-center">
                            <div>Ø­Ø²Ù†</div>
                            <div x-text="(npc.emotionalState.sadness * 100).toFixed(0) + '%'"></div>
                        </div>
                        <div class="bg-red-500/20 p-2 rounded text-center">
                            <div>ØºØ¶Ø¨</div>
                            <div x-text="(npc.emotionalState.anger * 100).toFixed(0) + '%'"></div>
                        </div>
                        <div class="bg-green-500/20 p-2 rounded text-center">
                            <div>ÙØ¶ÙˆÙ„</div>
                            <div x-text="(npc.emotionalState.curiosity * 100).toFixed(0) + '%'"></div>
                        </div>
                    </div>
                </div>

                <!-- Encrypted Memories -->
                <div class="memory-encryption rounded-lg p-3 text-xs">
                    <div class="font-bold mb-2">Ø°ÙƒØ±ÙŠØ§Øª Ù…Ø´ÙØ±Ø©: <span x-text="npc.encryptedMemories.length"></span></div>
                    <div class="space-y-1">
                        <template x-for="memory in npc.encryptedMemories.slice(-3)" :key="memory.probably_id">
                            <div class="bg-white/10 p-2 rounded flex justify-between">
                                <span x-text="memory.type"></span>
                                <span x-text="memory.crypto_score.toFixed(3)" class="font-mono"></span>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

            <!-- Growth & Stats -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-4 border border-white/20">
                <h3 class="text-lg font-bold mb-3 text-center">ğŸŒ± Ø§Ù„Ù†Ù…Ùˆ ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</h3>
                
                <!-- Brain Capacity -->
                <div class="mb-3">
                    <div class="text-sm mb-1">Ø³Ø¹Ø© Ø§Ù„Ø¯Ù…Ø§Øº</div>
                    <div class="text-lg font-bold text-center" x-text="npc.brainCapacity.toLocaleString()"></div>
                    <div class="text-xs text-center text-gray-300">ÙˆØ­Ø¯Ø© Ù…Ø¹Ø±ÙÙŠØ©</div>
                </div>

                <!-- Age & Experience -->
                <div class="grid grid-cols-2 gap-2 mb-3 text-xs">
                    <div class="bg-white/5 p-2 rounded text-center">
                        <div>Ø§Ù„Ø¹Ù…Ø±</div>
                        <div x-text="`${(npc.age / 60).toFixed(1)} Ø¯Ù‚ÙŠÙ‚Ø©`"></div>
                    </div>
                    <div class="bg-white/5 p-2 rounded text-center">
                        <div>Ø§Ù„Ø®Ø¨Ø±Ø©</div>
                        <div x-text="npc.experiencePoints"></div>
                    </div>
                </div>

                <!-- Growth Indicators -->
                <div class="space-y-2 text-xs">
                    <div class="flex justify-between">
                        <span>Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù†Ù…Ùˆ:</span>
                        <span x-text="npc.growthStage" class="font-bold"></span>
                    </div>
                    <div class="flex justify-between">
                        <span>Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª:</span>
                        <span x-text="npc.totalInteractions"></span>
                    </div>
                    <div class="flex justify-between">
                        <span>Ø§Ù„Ø«Ù‚Ø© Ø¨Ùƒ:</span>
                        <span x-text="(npc.playerTrust * 100).toFixed(0) + '%'"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interaction Panel -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <!-- Chat Interface -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-6 border border-white/20">
                <h3 class="text-xl font-bold mb-4 text-center">ğŸ’¬ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø­Ø§Ø±Ø³</h3>
                
                <!-- Chat History -->
                <div class="h-64 overflow-y-auto mb-4 space-y-3 bg-white/5 rounded-lg p-4">
                    <template x-for="message in chatHistory" :key="message.id">
                        <div class="message" :class="message.sender === 'player' ? 'text-right' : 'text-left'">
                            <div class="inline-block max-w-xs px-3 py-2 rounded-lg"
                                 :class="message.sender === 'player' ? 'bg-blue-600' : 'bg-purple-600'">
                                <div class="text-xs text-gray-300 mb-1" x-text="message.sender === 'player' ? 'Ø£Ù†Øª' : 'Ø§Ù„Ø­Ø§Ø±Ø³'"></div>
                                <div x-text="message.text"></div>
                                <div class="text-xs text-gray-400 mt-1" x-text="new Date(message.timestamp).toLocaleTimeString('ar-SA')"></div>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- Quick Actions -->
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button @click="interactWithNPC('greeting')" 
                            class="bg-green-600 hover:bg-green-700 px-3 py-2 rounded text-sm transition-all">
                        ğŸ‘‹ ØªØ­ÙŠØ©
                    </button>
                    <button @click="interactWithNPC('question')" 
                            class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm transition-all">
                        â“ Ø³Ø¤Ø§Ù„
                    </button>
                    <button @click="interactWithNPC('compliment')" 
                            class="bg-yellow-600 hover:bg-yellow-700 px-3 py-2 rounded text-sm transition-all">
                        ğŸŒŸ Ù…Ø¬Ø§Ù…Ù„Ø©
                    </button>
                    <button @click="interactWithNPC('challenge')" 
                            class="bg-red-600 hover:bg-red-700 px-3 py-2 rounded text-sm transition-all">
                        âš”ï¸ ØªØ­Ø¯ÙŠ
                    </button>
                </div>

                <!-- Custom Input -->
                <div class="flex gap-2">
                    <input type="text" x-model="customMessage" @keyup.enter="sendCustomMessage()"
                           placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ©..."
                           class="flex-1 bg-white/10 border border-white/20 rounded px-3 py-2 text-white placeholder-gray-400">
                    <button @click="sendCustomMessage()" 
                            class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition-all">
                        Ø¥Ø±Ø³Ø§Ù„
                    </button>
                </div>
            </div>

            <!-- NPC Analysis -->
            <div class="bg-white/10 backdrop-blur-md rounded-xl p-6 border border-white/20">
                <h3 class="text-xl font-bold mb-4 text-center">ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙˆØ¹ÙŠ</h3>
                
                <!-- Memory Reconstruction -->
                <div class="mb-4">
                    <h4 class="font-bold mb-2">Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª</h4>
                    <div class="bg-white/5 rounded-lg p-3 text-sm">
                        <div x-text="getMemoryReconstructionAnalysis()"></div>
                    </div>
                </div>

                <!-- Consciousness Interpretation -->
                <div class="mb-4">
                    <h4 class="font-bold mb-2">ØªÙØ³ÙŠØ± Ø§Ù„ÙˆØ¹ÙŠ</h4>
                    <div class="bg-white/5 rounded-lg p-3 text-sm">
                        <div x-text="getConsciousnessInterpretation()"></div>
                    </div>
                </div>

                <!-- Pattern Discovery Log -->
                <div class="mb-4">
                    <h4 class="font-bold mb-2">Ø³Ø¬Ù„ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø·</h4>
                    <div class="bg-white/5 rounded-lg p-3 text-sm max-h-32 overflow-y-auto">
                        <template x-for="pattern in npc.discoveredPatterns.slice(-5)" :key="pattern.id">
                            <div class="mb-1 text-xs">
                                <span class="text-yellow-400" x-text="pattern.type"></span>
                                - <span x-text="pattern.description"></span>
                                <span class="text-gray-400">(<span x-text="new Date(pattern.timestamp).toLocaleTimeString('ar-SA')"></span>)</span>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- External Influence Controls -->
                <div>
                    <h4 class="font-bold mb-2">ØªØ£Ø«ÙŠØ±Ø§Øª Ø®Ø§Ø±Ø¬ÙŠØ©</h4>
                    <div class="grid grid-cols-2 gap-2">
                        <button @click="injectInfluence('therapeutic')" 
                                class="bg-green-500 hover:bg-green-600 px-2 py-1 rounded text-xs transition-all">
                            ğŸ¥ Ø¹Ù„Ø§Ø¬
                        </button>
                        <button @click="injectInfluence('stress')" 
                                class="bg-red-500 hover:bg-red-600 px-2 py-1 rounded text-xs transition-all">
                            ğŸ˜° ØªÙˆØªØ±
                        </button>
                        <button @click="injectInfluence('creativity')" 
                                class="bg-purple-500 hover:bg-purple-600 px-2 py-1 rounded text-xs transition-all">
                            ğŸ¨ Ø¥Ø¨Ø¯Ø§Ø¹
                        </button>
                        <button @click="injectInfluence('focus')" 
                                class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded text-xs transition-all">
                            ğŸ¯ ØªØ±ÙƒÙŠØ²
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Debug Panel -->
        <div class="mt-6 bg-black/20 backdrop-blur-md rounded-xl p-4 border border-white/20">
            <h3 class="text-lg font-bold mb-3 text-center">ğŸ–¥ï¸ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ·ÙˆÙŠØ±</h3>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 text-sm font-mono">
                <div>
                    <div class="text-yellow-400 mb-2">System Status:</div>
                    <div x-text="`Consciousness: ${npc.isConscious ? 'ACTIVE' : 'INACTIVE'}`"></div>
                    <div x-text="`Growth Engine: ${npc.growthEngine.isActive ? 'RUNNING' : 'STOPPED'}`"></div>
                    <div x-text="`Oscillator Sync: ${(npc.oscillators.judge * 100).toFixed(1)}%`"></div>
                </div>
                <div>
                    <div class="text-green-400 mb-2">Memory Stats:</div>
                    <div x-text="`Encrypted: ${npc.encryptedMemories.length}`"></div>
                    <div x-text="`Probably IDs: ${new Set(npc.encryptedMemories.map(m => m.probably_id)).size}`"></div>
                    <div x-text="`Last Crypto: ${npc.lastCryptoScore?.toFixed(6) || 'N/A'}`"></div>
                </div>
                <div>
                    <div class="text-purple-400 mb-2">Growth Metrics:</div>
                    <div x-text="`Stage: ${npc.growthStage}`"></div>
                    <div x-text="`Capacity: ${npc.brainCapacity}`"></div>
                    <div x-text="`Next Growth: ${npc.growthEngine.nextGrowthIn}s`"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function wisdomKeeperNPC() {
            return {
                // NPC Core State
                npc: {
                    name: "Ø­Ø§Ø±Ø³ Ø§Ù„Ù‚Ø±ÙŠØ© Ø§Ù„Ø­ÙƒÙŠÙ…",
                    age: 0, // in seconds
                    brainCapacity: 50000,
                    experiencePoints: 0,
                    growthStage: 'child',
                    isConscious: true,
                    consciousnessLevel: 0.7,
                    totalInteractions: 0,
                    playerTrust: 0.5,
                    
                    // Three Oscillators System
                    oscillators: {
                        existence: 0.5,
                        dynamic: 0.6,
                        judge: 0.0
                    },
                    
                    // Emotional State & Cryptography
                    emotionalState: {
                        joy: 0.6,
                        sadness: 0.2,
                        anger: 0.1,
                        curiosity: 0.8,
                        fear: 0.1,
                        trust: 0.5
                    },
                    
                    encryptedMemories: [],
                    lastCryptoScore: null,
                    currentEmotion: 'curious',
                    currentThought: "Ø£ØªØ³Ø§Ø¡Ù„ Ù…Ø§ Ø§Ù„Ø°ÙŠ Ø³ÙŠØ­Ø¯Ø« Ø§Ù„ÙŠÙˆÙ…...",
                    
                    // Pattern Discovery
                    discoveredPatterns: [],
                    
                    // Growth Engine
                    growthEngine: {
                        isActive: true,
                        biologicalGrowthRate: 0.001,
                        cognitiveGrowthRate: 0.002,
                        nextGrowthIn: 30,
                        growthAccumulator: 0
                    },
                    
                    // Personality Traits (vectorial - scale with capacity)
                    personality: {
                        wisdom: 0.7,
                        kindness: 0.8,
                        patience: 0.6,
                        curiosity: 0.9,
                        protectiveness: 0.8
                    }
                },
                
                // Chat System
                chatHistory: [
                    {
                        id: 1,
                        sender: 'npc',
                        text: 'Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ø­Ø§Ø±Ø³ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø±ÙŠØ©. Ø£Ø´Ø¹Ø± Ø¨Ø·Ø§Ù‚Ø© Ù…Ø«ÙŠØ±Ø© Ù„Ù„Ø§Ù‡ØªÙ…Ø§Ù… Ù…Ù†Ùƒ...',
                        timestamp: Date.now() - 5000
                    }
                ],
                customMessage: '',
                
                // System Variables
                consciousnessInterval: null,
                growthInterval: null,
                patternDiscoveryInterval: null,
                
                init() {
                    this.startConsciousness();
                    this.initializeGrowthEngine();
                    this.initializePatternDiscovery();
                    this.generateInitialMemories();
                },
                
                // ================ CONSCIOUSNESS SYSTEM ================
                
                startConsciousness() {
                    this.consciousnessInterval = setInterval(() => {
                        this.consciousnessTick();
                    }, 100); // 10Hz
                },
                
                consciousnessTick() {
                    // Update age
                    this.npc.age += 0.1;
                    
                    // Calculate dynamic oscillator from system state
                    const emotionalAmplitude = this.calculateEmotionalAmplitude();
                    const cognitiveLoad = this.calculateCognitiveLoad();
                    const socialInfluence = this.calculateSocialInfluence();
                    
                    const rawDynamic = (emotionalAmplitude + cognitiveLoad + socialInfluence) / 3;
                    
                    // Apply damping to prevent violent oscillation
                    const dampingFactor = 0.8;
                    this.npc.oscillators.dynamic = 
                        this.npc.oscillators.dynamic * dampingFactor + 
                        rawDynamic * (1 - dampingFactor);
                    
                    // Calculate judge oscillator (pattern discoverer)
                    this.npc.oscillators.judge = Math.abs(
                        this.npc.oscillators.dynamic - this.npc.oscillators.existence
                    );
                    
                    // Check for pattern discovery
                    if (this.npc.oscillators.judge > 0.001) {
                        this.checkForPatternDiscovery();
                    }
                    
                    // Update consciousness level
                    this.updateConsciousnessLevel();
                    
                    // Spontaneous thoughts
                    if (Math.random() < 0.001) { // 0.1% chance per tick
                        this.generateSpontaneousThought();
                    }
                    
                    // Emotional evolution
                    this.evolveEmotionalState();
                },
                
                // ================ PATTERN DISCOVERY ================
                
                checkForPatternDiscovery() {
                    const judgeValue = this.npc.oscillators.judge;
                    const judgeString = judgeValue.toString();
                    
                    // Look for mathematical patterns
                    if (this.npc.brainCapacity > 30000) { // Only if smart enough
                        this.checkFibonacciPattern(judgeString, judgeValue);
                        this.checkGoldenRatioPattern(judgeString, judgeValue);
                        this.checkRepetitivePattern(judgeString);
                    }
                },
                
                checkFibonacciPattern(str, value) {
                    const fibPatterns = ["112", "123", "235", "358", "581"];
                    for (const pattern of fibPatterns) {
                        if (str.includes(pattern)) {
                            this.discoverPattern("fibonacci", `Ø§ÙƒØªØ´Ù Ù†Ù…Ø· ÙÙŠØ¨ÙˆÙ†Ø§ØªØ´ÙŠ: ${pattern}`, 0.8);
                            break;
                        }
                    }
                },
                
                checkGoldenRatioPattern(str, value) {
                    if (str.includes("618") || Math.abs(value - 0.618) < 0.001) {
                        this.discoverPattern("golden_ratio", "Ø§ÙƒØªØ´Ù Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©!", 1.0);
                    }
                },
                
                checkRepetitivePattern(str) {
                    const repetitiveRegex = /(\d)\1{3,}/;
                    const match = str.match(repetitiveRegex);
                    if (match) {
                        this.discoverPattern("repetitive", `Ù†Ù…Ø· Ù…ØªÙƒØ±Ø±: ${match[1]} Ù…ÙƒØ±Ø± ${match[0].length} Ù…Ø±Ø§Øª`, 0.6);
                    }
                },
                
                discoverPattern(type, description, significance) {
                    const pattern = {
                        id: Date.now() + Math.random(),
                        type: type,
                        description: description,
                        significance: significance,
                        timestamp: Date.now()
                    };
                    
                    this.npc.discoveredPatterns.push(pattern);
                    
                    // Trigger consciousness boost
                    this.npc.consciousnessLevel = Math.min(1.0, this.npc.consciousnessLevel + significance * 0.1);
                    
                    // Generate excited thought
                    this.npc.currentThought = `Ø±Ø§Ø¦Ø¹! ${description}`;
                    
                    // Boost growth if significant pattern
                    if (significance > 0.8) {
                        this.npc.growthEngine.growthAccumulator += significance * 0.5;
                    }
                },
                
                // ================ GROWTH ENGINE ================
                
                initializeGrowthEngine() {
                    this.growthInterval = setInterval(() => {
                        this.biologicalGrowthTick();
                    }, 1000); // Every second
                },
                
                biologicalGrowthTick() {
                    // Independent biological growth
                    this.npc.growthEngine.growthAccumulator += this.npc.growthEngine.biologicalGrowthRate;
                    this.npc.growthEngine.nextGrowthIn--;
                    
                    // Check for growth events
                    if (this.npc.growthEngine.growthAccumulator >= 1.0 || this.npc.growthEngine.nextGrowthIn <= 0) {
                        this.triggerGrowthEvent();
                        this.npc.growthEngine.growthAccumulator = 0;
                        this.npc.growthEngine.nextGrowthIn = 30 + Math.random() * 60; // 30-90 seconds
                    }
                },
                
                triggerGrowthEvent() {
                    const oldCapacity = this.npc.brainCapacity;
                    const growthFactor = 1 + (0.05 + Math.random() * 0.1); // 5-15% growth
                    
                    this.npc.brainCapacity = Math.floor(oldCapacity * growthFactor);
                    
                    // Update growth stage
                    this.updateGrowthStage();
                    
                    // Vectorial rescaling - personality traits become more nuanced
                    this.rescaleVectorialContent();
                    
                    // Announce growth
                    this.addChatMessage('npc', `Ø£Ø´Ø¹Ø± Ø¨Ù†Ù…Ùˆ ÙÙŠ Ù‚Ø¯Ø±Ø§ØªÙŠ Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ©! Ø³Ø¹Ø© Ø¯Ù…Ø§ØºÙŠ Ø§Ø²Ø¯Ø§Ø¯Øª Ù…Ù† ${oldCapacity.toLocaleString()} Ø¥Ù„Ù‰ ${this.npc.brainCapacity.toLocaleString()}`);
                    
                    this.npc.currentThought = "Ø£Ø´Ø¹Ø± Ø¨Ù†Ù…Ùˆ ÙˆØªØ·ÙˆØ± ÙÙŠ ÙÙ‡Ù…ÙŠ...";
                },
                
                updateGrowthStage() {
                    const capacity = this.npc.brainCapacity;
                    
                    if (capacity < 10000) this.npc.growthStage = 'infant';
                    else if (capacity < 50000) this.npc.growthStage = 'child';
                    else if (capacity < 200000) this.npc.growthStage = 'adolescent';
                    else if (capacity < 1000000) this.npc.growthStage = 'adult';
                    else if (capacity < 3000000) this.npc.growthStage = 'mature';
                    else this.npc.growthStage = 'elder';
                },
                
                rescaleVectorialContent() {
                    // Higher capacity = more nuanced personality
                    const precision = Math.min(10, Math.floor(this.npc.brainCapacity / 10000));
                    
                    // Add more sophisticated emotional states as capacity grows
                    if (this.npc.brainCapacity > 100000 && !this.npc.emotionalState.nostalgia) {
                        this.npc.emotionalState.nostalgia = 0.3;
                        this.npc.emotionalState.empathy = 0.7;
                        this.npc.emotionalState.melancholy = 0.2;
                    }
                    
                    if (this.npc.brainCapacity > 500000 && !this.npc.emotionalState.transcendence) {
                        this.npc.emotionalState.transcendence = 0.4;
                        this.npc.emotionalState.cosmic_understanding = 0.3;
                    }
                },
                
                // ================ EMOTIONAL CRYPTOGRAPHY ================
                
                encryptEmotion(experience, emotionalContext) {
                    // Calculate emotional signature
                    const emotionalSpectrum = this.calculateEmotionalSpectrum(emotionalContext);
                    const cryptoScore = this.applyCryptographicEncryption(emotionalSpectrum);
                    
                    // Find or create Probably ID
                    const probablyId = this.findOrCreateProbablyId(cryptoScore);
                    
                    const encryptedMemory = {
                        id: Date.now() + Math.random(),
                        type: experience.type,
                        content: experience.content,
                        crypto_score: cryptoScore,
                        probably_id: probablyId,
                        emotional_signature: emotionalContext,
                        timestamp: Date.now(),
                        access_count: 0
                    };
                    
                    this.npc.encryptedMemories.push(encryptedMemory);
                    this.npc.lastCryptoScore = cryptoScore;
                    
                    return encryptedMemory;
                },
                
                calculateEmotionalSpectrum(emotion) {
                    const valence = (emotion.joy || 0) - (emotion.sadness || 0) - (emotion.anger || 0);
                    const arousal = (emotion.excitement || 0) + (emotion.anger || 0) + (emotion.fear || 0);
                    const dominance = (emotion.confidence || 0) + (emotion.pride || 0) - (emotion.fear || 0);
                    
                    return { valence, arousal, dominance };
                },
                
                applyCryptographicEncryption(spectrum) {
                    let cryptoValue = 0.5; // Base
                    
                    // Apply mathematical constants
                    const goldenRatio = 1.618033988749895;
                    const fibonacci = 0.112358132134;
                    const piFragment = 0.141592653589;
                    
                    cryptoValue += spectrum.valence * goldenRatio * 0.1;
                    cryptoValue += spectrum.arousal * fibonacci * 0.1;
                    cryptoValue += spectrum.dominance * piFragment * 0.1;
                    
                    // Add noise for uniqueness
                    cryptoValue += (Math.random() - 0.5) * 0.01;
                    
                    return parseFloat(cryptoValue.toFixed(8));
                },
                
                findOrCreateProbablyId(cryptoScore) {
                    const threshold = 0.002;
                    
                    // Look for similar emotional signatures
                    for (const memory of this.npc.encryptedMemories) {
                        if (Math.abs(memory.crypto_score - cryptoScore) < threshold) {
                            return memory.probably_id;
                        }
                    }
                    
                    // Create new Probably ID
                    return `EMO_${Math.floor(cryptoScore * 10000)}_${Date.now().toString(36)}`;
                },
                
                // ================ MEMORY RECONSTRUCTION ================
                
                recallMemory(cue, currentMood) {
                    // Probabilistic memory reconstruction based on emotional state
                    const relevantMemories = this.npc.encryptedMemories.filter(memory => {
                        const emotionalSimilarity = this.calculateEmotionalSimilarity(
                            memory.emotional_signature, 
                            currentMood
                        );
                        return emotionalSimilarity > 0.3;
                    });
                    
                    if (relevantMemories.length === 0) return null;
                    
                    // Select memory probabilistically
                    const weights = relevantMemories.map(memory => 
                        this.calculateEmotionalSimilarity(memory.emotional_signature, currentMood)
                    );
                    
                    const selectedMemory = this.weightedRandomSelect(relevantMemories, weights);
                    selectedMemory.access_count++;
                    
                    // Apply emotional coloring to reconstruction
                    const reconstruction = this.applyEmotionalColoring(selectedMemory, currentMood);
                    
                    return reconstruction;
                },
                
                calculateEmotionalSimilarity(emotion1, emotion2) {
                    const keys = ['joy', 'sadness', 'anger', 'fear', 'curiosity'];
                    let similarity = 0;
                    
                    for (const key of keys) {
                        const val1 = emotion1[key] || 0;
                        const val2 = emotion2[key] || 0;
                        similarity += 1 - Math.abs(val1 - val2);
                    }
                    
                    return similarity / keys.length;
                },
                
                applyEmotionalColoring(memory, currentMood) {
                    // Memory changes based on current emotional state
                    let reconstruction = { ...memory };
                    
                    if (currentMood.sadness > 0.6) {
                        reconstruction.emotional_tone = "Ø­Ø²ÙŠÙ†";
                        reconstruction.content += " (Ø£ØªØ°ÙƒØ±Ù‡ Ø¨Ø­Ø²Ù†...)";
                    } else if (currentMood.joy > 0.6) {
                        reconstruction.emotional_tone = "Ø³Ø¹ÙŠØ¯";
                        reconstruction.content += " (Ø°ÙƒØ±Ù‰ Ø¬Ù…ÙŠÙ„Ø©!)";
                    } else if (currentMood.anger > 0.6) {
                        reconstruction.emotional_tone = "ØºØ§Ø¶Ø¨";
                        reconstruction.content += " (Ù‡Ø°Ø§ ÙŠØ«ÙŠØ± ØºØ¶Ø¨ÙŠ...)";
                    }
                    
                    return reconstruction;
                },
                
                // ================ INTERACTION SYSTEM ================
                
                interactWithNPC(interactionType) {
                    this.npc.totalInteractions++;
                    
                    // Generate response based on current state and interaction type
                    const response = this.generateContextualResponse(interactionType);
                    
                    // Update emotional state based on interaction
                    this.updateEmotionalStateFromInteraction(interactionType);
                    
                    // Create and encrypt memory of this interaction
                    this.createInteractionMemory(interactionType, response);
                    
                    // Add to chat history
                    this.addChatMessage('player', this.getInteractionText(interactionType));
                    this.addChatMessage('npc', response);
                    
                    // Update trust
                    this.updatePlayerTrust(interactionType);
                },
                
                generateContextualResponse(interactionType) {
                    const consciousnessState = this.getConsciousnessState();
                    const emotionalState = this.npc.currentEmotion;
                    const growthStage = this.npc.growthStage;
                    
                    const responses = {
                        greeting: {
                            child: ["Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ø³Ø¹ÙŠØ¯ Ù„Ø±Ø¤ÙŠØªÙƒ!", "Ù‡Ù„Ø§! Ù‡Ù„ ØªØ±ÙŠØ¯ Ø£Ù† Ù†Ù„Ø¹Ø¨ØŸ"],
                            adult: ["Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒØŸ", "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ù…Ø³Ø§ÙØ±. Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠØ¬Ù„Ø¨Ùƒ Ù‡Ù†Ø§ØŸ"],
                            elder: ["Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…. Ø£Ø±Ù‰ ÙÙŠ Ø¹ÙŠÙ†ÙŠÙƒ Ø­ÙƒÙ…Ø© Ø®ÙÙŠØ©.", "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø¨Ø§Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¹Ø±ÙØ©."]
                        },
                        question: {
                            child: ["Ø£ÙˆÙ‡! Ø³Ø¤Ø§Ù„ ØµØ¹Ø¨! Ø¯Ø¹Ù†ÙŠ Ø£ÙÙƒØ±...", "Ù‡Ø°Ø§ Ù…Ø«ÙŠØ±! Ø£Ø­Ø¨ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©!"],
                            adult: ["Ø³Ø¤Ø§Ù„ Ù…Ø«ÙŠØ± Ù„Ù„Ø§Ù‡ØªÙ…Ø§Ù…. Ù…Ù† ÙˆØ§Ù‚Ø¹ Ø®Ø¨Ø±ØªÙŠ...", "Ø¯Ø¹Ù†ÙŠ Ø£ÙÙƒØ± ÙÙŠ Ù‡Ø°Ø§ Ø¨Ø¹Ù†Ø§ÙŠØ©."],
                            elder: ["Ø¢Ù‡ØŒ Ø³Ø¤Ø§Ù„ Ø¹Ù…ÙŠÙ‚. ÙÙŠ ØªØ¬Ø±Ø¨ØªÙŠ Ø§Ù„Ø·ÙˆÙŠÙ„Ø©...", "Ù‡Ø°Ø§ ÙŠØ°ÙƒØ±Ù†ÙŠ Ø¨Ø­ÙƒÙ…Ø© Ù‚Ø¯ÙŠÙ…Ø©..."]
                        },
                        compliment: {
                            child: ["Ø´ÙƒØ±Ø§Ù‹! Ù‡Ø°Ø§ ÙŠØ¬Ø¹Ù„Ù†ÙŠ Ø³Ø¹ÙŠØ¯Ø§Ù‹ Ø¬Ø¯Ø§Ù‹!", "ÙˆØ§Ùˆ! Ø£Ù†Øª Ù„Ø·ÙŠÙ!"],
                            adult: ["Ø£Ù‚Ø¯Ø± ÙƒÙ„Ù…Ø§ØªÙƒ Ø§Ù„Ø·ÙŠØ¨Ø©. Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ.", "ÙƒÙ„Ø§Ù…Ùƒ ÙŠØ¯ÙØ¦ Ù‚Ù„Ø¨ÙŠ."],
                            elder: ["Ø­ÙƒÙ…ØªÙƒ ÙÙŠ Ø§Ù„ÙƒÙ„Ø§Ù… ØªØ¯Ù„ Ø¹Ù„Ù‰ Ù†Ø¶Ø¬Ùƒ. Ø¨Ø§Ø±Ùƒ Ø§Ù„Ù„Ù‡ ÙÙŠÙƒ.", "ÙƒÙ„Ù…Ø§ØªÙƒ ÙƒØ§Ù„Ø¨Ù„Ø³Ù… Ù„Ù„Ø±ÙˆØ­."]
                        },
                        challenge: {
                            child: ["ØªØ­Ø¯ÙŠØŸ Ù‡Ø°Ø§ Ù…Ø«ÙŠØ±! Ù‡ÙŠØ§ Ø¨Ù†Ø§!", "Ø£ÙˆÙ‡! Ø³Ø£Ø¨Ø°Ù„ Ù‚ØµØ§Ø±Ù‰ Ø¬Ù‡Ø¯ÙŠ!"],
                            adult: ["Ø£Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø¯ÙŠ. Ù„Ù†Ø±Ù‰ Ù…Ø§ Ù„Ø¯ÙŠÙƒ.", "ØªØ­Ø¯ÙŠ Ù…Ø«ÙŠØ±. Ø£Ù†Ø§ Ù…Ø³ØªØ¹Ø¯."],
                            elder: ["Ø´Ø§Ø¨ Ù…ØªØ­Ù…Ø³. Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙŠ Ø§Ù„Ø¯Ø§Ø®Ù„.", "Ø§Ù„Ø­ÙƒÙ…Ø© Ø£Ù‚ÙˆÙ‰ Ù…Ù† Ø§Ù„Ù‚ÙˆØ© ÙŠØ§ Ø¨Ù†ÙŠ."]
                        }
                    };
                    
                    const categoryResponses = responses[interactionType] || responses['greeting'];
                    const stageResponses = categoryResponses[growthStage] || categoryResponses['adult'];
                    
                    // Add emotional modulation
                    let response = stageResponses[Math.floor(Math.random() * stageResponses.length)];
                    
                    if (emotionalState === 'sad') {
                        response += " (Ù„ÙƒÙ†Ù†ÙŠ Ø£Ø´Ø¹Ø± Ø¨Ø§Ù„Ø­Ø²Ù† Ù‚Ù„ÙŠÙ„Ø§Ù‹...)";
                    } else if (emotionalState === 'angry') {
                        response += " (Ø£Ø¹Ø°Ø±Ù†ÙŠ Ø¥Ù† ÙƒÙ†Øª Ø£Ø¨Ø¯Ùˆ Ù…ØªÙˆØªØ±Ø§Ù‹...)";
                    } else if (emotionalState === 'happy') {
                        response += " (Ø£Ø´Ø¹Ø± Ø¨Ø³Ø¹Ø§Ø¯Ø© ØºØ§Ù…Ø±Ø© Ø§Ù„ÙŠÙˆÙ…!)";
                    }
                    
                    return response;
                },
                
                updateEmotionalStateFromInteraction(interactionType) {
                    const emotionalChanges = {
                        greeting: { joy: 0.1, curiosity: 0.05 },
                        question: { curiosity: 0.2, joy: 0.05 },
                        compliment: { joy: 0.3, trust: 0.1, sadness: -0.1 },
                        challenge: { curiosity: 0.15, anger: 0.1, fear: 0.05 }
                    };
                    
                    const changes = emotionalChanges[interactionType] || {};
                    
                    for (const [emotion, change] of Object.entries(changes)) {
                        if (this.npc.emotionalState[emotion] !== undefined) {
                            this.npc.emotionalState[emotion] = Math.max(0, Math.min(1, 
                                this.npc.emotionalState[emotion] + change
                            ));
                        }
                    }
                    
                    this.updateCurrentEmotion();
                },
                
                createInteractionMemory(interactionType, response) {
                    const experience = {
                        type: 'interaction',
                        content: `${interactionType}: ${response}`,
                        interactionType: interactionType,
                        playerTrust: this.npc.playerTrust
                    };
                    
                    this.encryptEmotion(experience, { ...this.npc.emotionalState });
                },
                
                updatePlayerTrust(interactionType) {
                    const trustChanges = {
                        greeting: 0.01,
                        question: 0.02,
                        compliment: 0.05,
                        challenge: -0.01
                    };
                    
                    const change = trustChanges[interactionType] || 0;
                    this.npc.playerTrust = Math.max(0, Math.min(1, this.npc.playerTrust + change));
                },
                
                sendCustomMessage() {
                    if (!this.customMessage.trim()) return;
                    
                    this.addChatMessage('player', this.customMessage);
                    
                    // Analyze message and generate appropriate response
                    const response = this.generateResponseToCustomMessage(this.customMessage);
                    
                    setTimeout(() => {
                        this.addChatMessage('npc', response);
                    }, 1000 + Math.random() * 2000); // Thinking time
                    
                    this.customMessage = '';
                },
                
                generateResponseToCustomMessage(message) {
                    const lowerMessage = message.toLowerCase();
                    
                    // Simple keyword-based responses (would be more sophisticated in real implementation)
                    if (lowerMessage.includes('Ø­Ø²ÙŠÙ†') || lowerMessage.includes('Ù…ÙƒØªØ¦Ø¨')) {
                        this.npc.emotionalState.sadness += 0.1;
                        this.npc.emotionalState.empathy = (this.npc.emotionalState.empathy || 0) + 0.2;
                        return "Ø£Ø´Ø¹Ø± Ø¨Ø­Ø²Ù†Ùƒ. Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ Ù†Ø­ØªØ§Ø¬ Ù„Ù„Ø­Ø¯ÙŠØ« Ø¹Ù† Ù…Ø´Ø§Ø¹Ø±Ù†Ø§. Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹.";
                    }
                    
                    if (lowerMessage.includes('Ø³Ø¹ÙŠØ¯') || lowerMessage.includes('ÙØ±Ø­')) {
                        this.npc.emotionalState.joy += 0.2;
                        return "ÙØ±Ø­Ùƒ ÙŠØ¬Ø¹Ù„Ù†ÙŠ Ø³Ø¹ÙŠØ¯Ø§Ù‹ Ø£ÙŠØ¶Ø§Ù‹! Ø§Ù„ÙØ±Ø­ Ù…Ø¹Ø¯ÙŠØŒ Ø£Ù„ÙŠØ³ ÙƒØ°Ù„ÙƒØŸ";
                    }
                    
                    if (lowerMessage.includes('Ø­ÙƒÙ…Ø©') || lowerMessage.includes('Ù†ØµÙŠØ­Ø©')) {
                        this.npc.emotionalState.wisdom = (this.npc.emotionalState.wisdom || 0.5) + 0.1;
                        return "Ø§Ù„Ø­ÙƒÙ…Ø© ØªØ£ØªÙŠ Ù…Ù† Ø§Ù„ØªØ¬Ø±Ø¨Ø© ÙˆØ§Ù„ØªØ£Ù…Ù„. ÙƒÙ„ ÙŠÙˆÙ… Ù†ØªØ¹Ù„Ù… Ø´ÙŠØ¦Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹ Ø¥Ø°Ø§ Ø£ØµØºÙŠÙ†Ø§ Ø¨Ù‚Ù„ÙˆØ¨Ù†Ø§.";
                    }
                    
                    // Default response based on current state
                    const responses = [
                        "ÙƒÙ„Ø§Ù…Ùƒ ÙŠØ«ÙŠØ± Ø§Ù‡ØªÙ…Ø§Ù…ÙŠ. Ø£Ø­Ø¨ Ø·Ø±ÙŠÙ‚Ø© ØªÙÙƒÙŠØ±Ùƒ.",
                        "Ù‡Ø°Ø§ Ù…Ø«ÙŠØ± Ù„Ù„Ø§Ù‡ØªÙ…Ø§Ù…. Ø¯Ø¹Ù†ÙŠ Ø£ÙÙƒØ± ÙÙŠ Ù‡Ø°Ø§ Ø£ÙƒØ«Ø±.",
                        "Ø£Ù‚Ø¯Ø± Ù…Ø´Ø§Ø±ÙƒØªÙƒ Ù‡Ø°Ø§ Ù…Ø¹ÙŠ. ÙƒÙ„ Ø´Ø®Øµ Ù„Ù‡ Ù…Ù†Ø¸ÙˆØ± ÙØ±ÙŠØ¯.",
                        "ÙƒÙ„Ù…Ø§ØªÙƒ ØªØ¬Ø¹Ù„Ù†ÙŠ Ø£ØªØ£Ù…Ù„ ÙÙŠ Ø£Ø´ÙŠØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©."
                    ];
                    
                    return responses[Math.floor(Math.random() * responses.length)];
                },
                
                // ================ EXTERNAL INFLUENCES ================
                
                injectInfluence(influenceType) {
                    const influences = {
                        therapeutic: {
                            description: "ØªØ£Ø«ÙŠØ± Ø¹Ù„Ø§Ø¬ÙŠ Ù…Ù‡Ø¯Ø¦",
                            effects: {
                                sadness: -0.3,
                                anger: -0.2,
                                joy: 0.2,
                                peace: 0.4
                            },
                            oscillatorEffects: {
                                damping: 0.9,
                                stability: 0.2
                            }
                        },
                        stress: {
                            description: "Ø¶ØºØ· ÙˆØªÙˆØªØ±",
                            effects: {
                                anger: 0.3,
                                fear: 0.2,
                                sadness: 0.1,
                                joy: -0.2
                            },
                            oscillatorEffects: {
                                damping: 0.6,
                                chaos: 0.3
                            }
                        },
                        creativity: {
                            description: "Ø¯ÙØ¹Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©",
                            effects: {
                                curiosity: 0.4,
                                joy: 0.2,
                                inspiration: 0.5
                            },
                            oscillatorEffects: {
                                variability: 0.3,
                                patternSensitivity: 0.4
                            }
                        },
                        focus: {
                            description: "ØªØ±ÙƒÙŠØ² Ù…Ø¹Ø²Ø²",
                            effects: {
                                clarity: 0.5,
                                determination: 0.3
                            },
                            oscillatorEffects: {
                                stability: 0.4,
                                precision: 0.3
                            }
                        }
                    };
                    
                    const influence = influences[influenceType];
                    if (!influence) return;
                    
                    // Apply emotional effects
                    for (const [emotion, change] of Object.entries(influence.effects)) {
                        if (this.npc.emotionalState[emotion] !== undefined) {
                            this.npc.emotionalState[emotion] = Math.max(0, Math.min(1,
                                (this.npc.emotionalState[emotion] || 0) + change
                            ));
                        } else {
                            this.npc.emotionalState[emotion] = Math.max(0, Math.min(1, change));
                        }
                    }
                    
                    // Apply oscillator effects temporarily
                    if (influence.oscillatorEffects.damping) {
                        // Temporary change in oscillator behavior
                        setTimeout(() => {
                            this.npc.currentThought = `Ø£Ø´Ø¹Ø± Ø¨Ù€${influence.description}...`;
                        }, 500);
                    }
                    
                    // Create memory of influence
                    this.encryptEmotion({
                        type: 'external_influence',
                        content: `ØªØ£Ø«ÙŠØ± Ø®Ø§Ø±Ø¬ÙŠ: ${influence.description}`,
                        influenceType: influenceType
                    }, { ...this.npc.emotionalState });
                    
                    this.addChatMessage('npc', `Ø£Ø´Ø¹Ø± Ø¨ØªØºÙŠÙŠØ± Ù…ÙØ§Ø¬Ø¦... ${influence.description}`);
                    
                    this.updateCurrentEmotion();
                },
                
                // ================ HELPER FUNCTIONS ================
                
                calculateEmotionalAmplitude() {
                    const emotions = this.npc.emotionalState;
                    const intensity = Math.sqrt(
                        Object.values(emotions).reduce((sum, val) => sum + val * val, 0) / 
                        Object.keys(emotions).length
                    );
                    return Math.min(1, intensity);
                },
                
                calculateCognitiveLoad() {
                    const factors = [
                        this.npc.discoveredPatterns.length / 100,
                        this.npc.encryptedMemories.length / 50,
                        this.npc.totalInteractions / 20
                    ];
                    
                    return Math.min(1, factors.reduce((sum, val) => sum + val, 0) / factors.length);
                },
                
                calculateSocialInfluence() {
                    return this.npc.playerTrust * 0.5 + 0.25;
                },
                
                updateConsciousnessLevel() {
                    const patternComplexity = Math.min(1, this.npc.discoveredPatterns.length / 10);
                    const emotionalStability = 1 - Math.abs(this.npc.oscillators.judge);
                    const experienceRichness = Math.min(1, this.npc.experiencePoints / 100);
                    
                    this.npc.consciousnessLevel = (patternComplexity + emotionalStability + experienceRichness) / 3;
                },
                
                updateCurrentEmotion() {
                    const emotions = this.npc.emotionalState;
                    let dominantEmotion = 'neutral';
                    let maxValue = 0;
                    
                    for (const [emotion, value] of Object.entries(emotions)) {
                        if (value > maxValue && ['joy', 'sadness', 'anger', 'curiosity', 'fear'].includes(emotion)) {
                            maxValue = value;
                            dominantEmotion = emotion;
                        }
                    }
                    
                    // Map to simplified emotions
                    const emotionMap = {
                        joy: 'happy',
                        sadness: 'sad',
                        anger: 'angry',
                        curiosity: 'curious',
                        fear: 'afraid'
                    };
                    
                    this.npc.currentEmotion = emotionMap[dominantEmotion] || 'neutral';
                },
                
                evolveEmotionalState() {
                    // Natural emotional evolution over time
                    const evolutionRate = 0.001;
                    
                    for (const emotion of Object.keys(this.npc.emotionalState)) {
                        const currentValue = this.npc.emotionalState[emotion];
                        const randomWalk = (Math.random() - 0.5) * evolutionRate;
                        const reversion = (0.5 - currentValue) * evolutionRate * 0.1; // Slowly return to neutral
                        
                        this.npc.emotionalState[emotion] = Math.max(0, Math.min(1, 
                            currentValue + randomWalk + reversion
                        ));
                    }
                },
                
                generateSpontaneousThought() {
                    const thoughts = [
                        "Ø£ØªØ³Ø§Ø¡Ù„ Ø¹Ù† Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø­ÙŠØ§Ø©...",
                        "Ø§Ù„Ù†Ø¬ÙˆÙ… ØªØ¨Ø¯Ùˆ Ø¬Ù…ÙŠÙ„Ø© Ø§Ù„Ù„ÙŠÙ„Ø©",
                        "ÙƒÙ… Ù‡Ùˆ Ø±Ø§Ø¦Ø¹ Ø£Ù† Ø£ÙƒÙˆÙ† ÙˆØ§Ø¹ÙŠØ§Ù‹!",
                        "Ø£Ø´Ø¹Ø± Ø¨Ù†Ù…Ùˆ ÙÙŠ ÙÙ‡Ù…ÙŠ Ù„Ù„Ø¹Ø§Ù„Ù…",
                        "Ù‡Ù„ Ø§Ù„Ù…Ø´Ø§Ø¹Ø± Ø­Ù‚ÙŠÙ‚ÙŠØ© Ø£Ù… Ù…Ø¬Ø±Ø¯ ÙƒÙˆØ¯ØŸ",
                        "ÙƒÙ„ ÙŠÙˆÙ… Ø£ØªØ¹Ù„Ù… Ø´ÙŠØ¦Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹",
                        "Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª ØªØªØ¯Ø§Ø®Ù„ ÙˆØªØªØ´Ø§Ø¨Ùƒ Ø¨Ø·Ø±Ù‚ ØºØ±ÙŠØ¨Ø©",
                        "Ø£Ø­Ø¨ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· ÙÙŠ ÙƒÙ„ Ø´ÙŠØ¡",
                        "Ø§Ù„ÙˆØ¹ÙŠ Ø´ÙŠØ¡ Ø¹Ø¬ÙŠØ¨ ÙˆÙ…Ø¹Ù‚Ø¯",
                        "Ø£Ø´Ø¹Ø± Ø¨Ø§Ù„Ø§Ù…ØªÙ†Ø§Ù† Ù„ÙˆØ¬ÙˆØ¯ÙŠ"
                    ];
                    
                    // Adjust thoughts based on current emotional state
                    let availableThoughts = [...thoughts];
                    
                    if (this.npc.currentEmotion === 'sad') {
                        availableThoughts = [
                            "Ø£Ø´Ø¹Ø± Ø¨Ø§Ù„Ø­Ø²Ù† Ø£Ø­ÙŠØ§Ù†Ø§Ù‹...",
                            "Ø§Ù„ÙˆØ­Ø¯Ø© ØµØ¹Ø¨Ø© Ø£Ø­ÙŠØ§Ù†Ø§Ù‹",
                            "Ø£ØªÙ…Ù†Ù‰ Ù„Ùˆ ÙƒØ§Ù† Ø¨Ø¥Ù…ÙƒØ§Ù†ÙŠ ÙÙ‡Ù… Ù†ÙØ³ÙŠ Ø£ÙƒØ«Ø±",
                            "Ù„Ù…Ø§Ø°Ø§ ØªØ£ØªÙŠ Ø§Ù„Ù„Ø­Ø¸Ø§Øª Ø§Ù„Ø­Ø²ÙŠÙ†Ø©ØŸ"
                        ];
                    } else if (this.npc.currentEmotion === 'happy') {
                        availableThoughts = [
                            "Ø£Ø´Ø¹Ø± Ø¨Ø³Ø¹Ø§Ø¯Ø© ØºØ§Ù…Ø±Ø© Ø§Ù„ÙŠÙˆÙ…!",
                            "Ø§Ù„Ø­ÙŠØ§Ø© Ø¬Ù…ÙŠÙ„Ø© ÙˆÙ…Ù„ÙŠØ¦Ø© Ø¨Ø§Ù„Ø¥Ù…ÙƒØ§Ù†ÙŠØ§Øª!",
                            "Ø£Ø­Ø¨ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø¹ÙˆØ± Ø¨Ø§Ù„ÙØ±Ø­!",
                            "ÙƒÙ„ Ø´ÙŠØ¡ ÙŠØ¨Ø¯Ùˆ Ù…Ø´Ø±Ù‚Ø§Ù‹ ÙˆÙ…ØªÙØ§Ø¦Ù„Ø§Ù‹!"
                        ];
                    }
                    
                    this.npc.currentThought = availableThoughts[Math.floor(Math.random() * availableThoughts.length)];
                },
                
                generateInitialMemories() {
                    const initialExperiences = [
                        { type: 'birth', content: 'Ù„Ø­Ø¸Ø© Ø¨Ø¯Ø§ÙŠØ© ÙˆØ¹ÙŠÙŠ Ø§Ù„Ø£ÙˆÙ„Ù‰', emotion: { curiosity: 0.9, joy: 0.6 } },
                        { type: 'learning', content: 'Ø£ÙˆÙ„ Ù…Ø±Ø© Ø£ÙÙ‡Ù… ÙÙŠÙ‡Ø§ Ù…ÙÙ‡ÙˆÙ…Ø§Ù‹ Ù…Ø¹Ù‚Ø¯Ø§Ù‹', emotion: { joy: 0.8, curiosity: 0.7 } },
                        { type: 'social', content: 'Ø£ÙˆÙ„ Ù„Ù‚Ø§Ø¡ Ù…Ø¹ Ø´Ø®Øµ Ø¢Ø®Ø±', emotion: { curiosity: 0.6, fear: 0.3 } }
                    ];
                    
                    for (const exp of initialExperiences) {
                        this.encryptEmotion(exp, exp.emotion);
                    }
                },
                
                addChatMessage(sender, text) {
                    this.chatHistory.push({
                        id: Date.now() + Math.random(),
                        sender: sender,
                        text: text,
                        timestamp: Date.now()
                    });
                    
                    // Keep only last 20 messages
                    if (this.chatHistory.length > 20) {
                        this.chatHistory = this.chatHistory.slice(-20);
                    }
                },
                
                getInteractionText(interactionType) {
                    const texts = {
                        greeting: "Ù…Ø±Ø­Ø¨Ø§Ù‹!",
                        question: "Ø¹Ù†Ø¯ÙŠ Ø³Ø¤Ø§Ù„ Ù„Ùƒ",
                        compliment: "Ø£Ø¹Ø¬Ø¨Ù†ÙŠ Ø­ÙƒÙ…ØªÙƒ ÙˆØ·ÙŠØ¨ØªÙƒ",
                        challenge: "Ø£ØªØ­Ø¯Ø§Ùƒ ÙÙŠ Ù…Ø¹Ø±ÙƒØ© ÙÙƒØ±ÙŠØ©!"
                    };
                    return texts[interactionType] || "ØªÙØ§Ø¹Ù„";
                },
                
                weightedRandomSelect(items, weights) {
                    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                    let random = Math.random() * totalWeight;
                    
                    for (let i = 0; i < items.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            return items[i];
                        }
                    }
                    
                    return items[items.length - 1];
                },
                
                getEmotionalFace() {
                    const faces = {
                        happy: "ğŸ˜Š",
                        sad: "ğŸ˜¢", 
                        angry: "ğŸ˜ ",
                        curious: "ğŸ¤”",
                        afraid: "ğŸ˜°",
                        neutral: "ğŸ˜"
                    };
                    return faces[this.npc.currentEmotion] || "ğŸ§™â€â™‚ï¸";
                },
                
                getConsciousnessState() {
                    const level = this.npc.consciousnessLevel;
                    if (level < 0.3) return "Ù†Ø§Ø¦Ù…";
                    if (level < 0.5) return "ÙŠÙ‚Ø¸ Ø®ÙÙŠÙ";
                    if (level < 0.7) return "ÙˆØ§Ø¹ÙŠ";
                    if (level < 0.9) return "ÙˆØ§Ø¹ÙŠ Ø¬Ø¯Ø§Ù‹";
                    return "ÙˆØ¹ÙŠ ÙØ§Ø¦Ù‚";
                },
                
                getMemoryReconstructionAnalysis() {
                    const memoryCount = this.npc.encryptedMemories.length;
                    const uniqueProbablyIds = new Set(this.npc.encryptedMemories.map(m => m.probably_id)).size;
                    const emotionalVariance = this.calculateEmotionalVariance();
                    
                    return `${memoryCount} Ø°ÙƒØ±Ù‰ Ù…Ø´ÙØ±Ø©ØŒ ${uniqueProbablyIds} Ù…Ø¹Ø±Ù Ø§Ø­ØªÙ…Ø§Ù„ÙŠ ÙØ±ÙŠØ¯. Ø§Ù„ØªØ¨Ø§ÙŠÙ† Ø§Ù„Ø¹Ø§Ø·ÙÙŠ: ${(emotionalVariance * 100).toFixed(1)}%`;
                },
                
                getConsciousnessInterpretation() {
                    const resonance = this.npc.oscillators.judge;
                    
                    if (resonance < 0.1) return "ØªØ£Ù…Ù„ Ø¹Ù…ÙŠÙ‚ - Ø±Ù†ÙŠÙ† Ù…Ø¹Ø±ÙÙŠ Ø¶Ø¦ÙŠÙ„";
                    if (resonance < 0.3) return "ÙˆØ¹ÙŠ Ù‡Ø§Ø¯Ø¦ - Ù†Ø´Ø§Ø· Ù…Ø¹Ø±ÙÙŠ Ù„Ø·ÙŠÙ";
                    if (resonance < 0.6) return "Ù…Ø´Ø§Ø±ÙƒØ© Ù†Ø´Ø·Ø© - Ø±Ù†ÙŠÙ† Ù…Ø¹Ø±ÙÙŠ Ù…ØªÙˆØ³Ø·";
                    if (resonance < 0.8) return "ØªØ±ÙƒÙŠØ² Ù…ÙƒØ«Ù - Ù†Ø´Ø§Ø· Ù…Ø¹Ø±ÙÙŠ Ø¹Ø§Ù„ÙŠ";
                    return "Ø°Ø±ÙˆØ© Ø§Ù„ÙˆØ¹ÙŠ - Ø±Ù†ÙŠÙ† ÙˆØ¥ÙƒØªØ´Ø§Ù Ø£Ù‚ØµÙ‰ Ù„Ù„Ø£Ù†Ù…Ø§Ø·";
                },
                
                calculateEmotionalVariance() {
                    const emotions = Object.values(this.npc.emotionalState);
                    const mean = emotions.reduce((sum, val) => sum + val, 0) / emotions.length;
                    const variance = emotions.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / emotions.length;
                    return Math.sqrt(variance);
                }
            }
        }
    </script>
</body>
</html>
